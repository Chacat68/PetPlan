# 战斗系统

## 概述

战斗系统是 Pet Plan 游戏的核心玩法之一，负责管理怪物生成、子弹系统、碰撞检测、伤害计算、爆炸效果等战斗相关的所有功能。

## 系统架构

### 核心组件
- **怪物系统**: 怪物生成、移动、渲染
- **子弹系统**: 子弹发射、移动、碰撞检测
- **爆炸系统**: 爆炸效果生成和渲染
- **战斗文字**: 伤害数字和奖励文字显示
- **碰撞检测**: 精确的碰撞判断算法

## 怪物系统

### 1. 怪物数据结构

```javascript
const monster = {
    // 位置和尺寸
    x: this.mapWidth,                    // X坐标 (从屏幕右边生成)
    y: playerY,                          // Y坐标 (与玩家同一水平线)
    width: 25,                           // 宽度
    height: 25,                          // 高度
    
    // 战斗属性
    hp: 30 + this.player.level * 10,     // 生命值 (随等级增长)
    maxHp: 30 + this.player.level * 10,  // 最大生命值
    attack: 8 + this.player.level * 2,   // 攻击力 (随等级增长)
    
    // 移动属性
    speed: 30 + Math.random() * 20,      // 移动速度 (随机变化)
    
    // 奖励
    coinReward: 5 + this.player.level,   // 金币奖励 (随等级增长)
    
    // 外观
    color: this.getRandomMonsterColor(), // 随机颜色
    
    // 无敌状态
    invulnerable: true,                  // 初始无敌状态
    invulnerableDistance: 100,           // 无敌距离
    spawnX: this.mapWidth                // 记录生成位置
};
```

### 2. 怪物生成 (spawnMonster)

```javascript
spawnMonster() {
    const groundY = this.mapHeight - 50;
    const playerY = groundY - this.player.height;
    
    const monster = {
        x: this.mapWidth, // 从屏幕右边生成
        y: playerY, // 与人物同一水平线
        width: 25,
        height: 25,
        hp: 30 + this.player.level * 10,
        maxHp: 30 + this.player.level * 10,
        attack: 8 + this.player.level * 2,
        speed: 30 + Math.random() * 20,
        coinReward: 5 + this.player.level,
        color: this.getRandomMonsterColor(),
        invulnerable: true, // 初始无敌状态
        invulnerableDistance: 100, // 无敌距离（像素）
        spawnX: this.mapWidth // 记录生成位置
    };
    
    this.monsters.push(monster);
}
```

**功能**: 生成新的怪物

**生成规则**:
- 从屏幕右边生成
- 与玩家同一水平线
- 属性随玩家等级增长
- 初始无敌状态

### 3. 怪物生成管理 (updateMonsterSpawn)

```javascript
updateMonsterSpawn(deltaTime) {
    this.monsterSpawnTimer += deltaTime;
    
    if (this.monsterSpawnTimer >= this.monsterSpawnInterval) {
        this.spawnMonster();
        this.monsterSpawnTimer = 0;
    }
}
```

**功能**: 管理怪物生成时机

**参数**:
- `deltaTime`: 时间差
- `monsterSpawnInterval`: 生成间隔 (默认2000ms)

### 4. 怪物更新 (updateMonsters)

```javascript
updateMonsters(deltaTime) {
    for (let i = this.monsters.length - 1; i >= 0; i--) {
        const monster = this.monsters[i];
        
        // 怪物向左移动（向玩家方向）
        monster.x -= monster.speed * (deltaTime / 1000);
        
        // 移除死亡的怪物
        if (monster.hp <= 0) {
            this.monsters.splice(i, 1);
            continue;
        }
        
        // 移除超出屏幕左边的怪物
        if (monster.x + monster.width < 0) {
            this.monsters.splice(i, 1);
        }
    }
}
```

**功能**: 更新所有怪物的状态

**更新内容**:
- 怪物移动
- 死亡检测
- 边界检测

### 5. 怪物渲染 (drawMonsters)

```javascript
drawMonsters() {
    const groundY = this.mapHeight - 50;
    
    this.monsters.forEach(monster => {
        // 确保怪物站在草地上
        const monsterY = groundY - monster.height;
        
        // 怪物身体
        this.ctx.fillStyle = monster.color;
        this.ctx.fillRect(monster.x, monsterY, monster.width, monster.height);
        
        // 怪物眼睛
        this.ctx.fillStyle = '#ff0000';
        this.ctx.fillRect(monster.x + 5, monsterY + 5, 4, 4);
        this.ctx.fillRect(monster.x + 15, monsterY + 5, 4, 4);
        
        // 绘制怪物脚部阴影（在草地上）
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        this.ctx.fillRect(monster.x - 2, groundY - 2, monster.width + 4, 4);
        
        // 生命值条 - 调整到怪物头顶上方
        this.drawHealthBar(monster.x, monsterY - 15, monster.width, 
                          monster.hp, monster.maxHp, '#ff4757', '#ff6b6b');
    });
}
```

**功能**: 渲染所有怪物

**渲染内容**:
- 怪物身体
- 怪物眼睛
- 脚部阴影
- 生命值条

### 6. 随机颜色生成 (getRandomMonsterColor)

```javascript
getRandomMonsterColor() {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd'];
    return colors[Math.floor(Math.random() * colors.length)];
}
```

**功能**: 为怪物生成随机颜色

## 子弹系统

### 1. 子弹数据结构

```javascript
const bullet = {
    // 位置和尺寸
    x: playerCenterX,        // X坐标
    y: playerCenterY,        // Y坐标
    width: 6,                // 宽度
    height: 6,               // 高度
    
    // 移动属性
    speed: 300,              // 移动速度
    dirX: 1,                 // X方向 (水平向右)
    dirY: 0,                 // Y方向 (垂直为0)
    
    // 战斗属性
    damage: this.player.attack, // 伤害值
    life: 2000,              // 存活时间 (2秒)
    
    // 视觉效果
    trail: []                // 子弹轨迹
};
```

### 2. 自动攻击系统 (updateAutoAttack)

```javascript
updateAutoAttack(deltaTime) {
    this.attackTimer += deltaTime;
    
    if (this.attackTimer >= this.attackInterval && this.monsters.length > 0) {
        // 找到攻击范围内最近的怪物
        let targetMonster = null;
        let minDistance = Infinity;
        
        for (let monster of this.monsters) {
            const distance = this.getDistance(this.player, monster);
            if (distance <= this.attackRange && distance < minDistance) {
                minDistance = distance;
                targetMonster = monster;
            }
        }
        
        // 如果找到目标，发射子弹
        if (targetMonster) {
            this.fireBullet(targetMonster);
            this.attackTimer = 0;
        }
    }
}
```

**功能**: 自动攻击系统

**攻击逻辑**:
- 检查攻击间隔
- 寻找最近目标
- 发射子弹

### 3. 子弹发射 (fireBullet)

```javascript
fireBullet(target) {
    const groundY = this.mapHeight - 50;
    const playerY = groundY - this.player.height;
    
    const playerCenterX = this.player.x + this.player.width / 2;
    const playerCenterY = playerY + this.player.height / 2;
    
    // 水平射击：子弹只向右水平飞行
    const bullet = {
        x: playerCenterX,
        y: playerCenterY,
        width: 6,
        height: 6,
        speed: 300,
        dirX: 1, // 水平向右
        dirY: 0, // 垂直方向为0，保持水平
        damage: this.player.attack,
        life: 2000, // 子弹存活时间2秒
        trail: [] // 子弹轨迹
    };
    
    this.bullets.push(bullet);
}
```

**功能**: 发射子弹

**子弹特性**:
- 水平飞行
- 固定伤害
- 2秒存活时间
- 轨迹记录

### 4. 子弹更新 (updateBullets)

```javascript
updateBullets(deltaTime) {
    for (let i = this.bullets.length - 1; i >= 0; i--) {
        const bullet = this.bullets[i];
        
        // 添加轨迹点
        bullet.trail.push({x: bullet.x, y: bullet.y, life: 200});
        
        // 移动子弹
        bullet.x += bullet.dirX * bullet.speed * (deltaTime / 1000);
        bullet.y += bullet.dirY * bullet.speed * (deltaTime / 1000);
        
        // 减少子弹生命
        bullet.life -= deltaTime;
        
        // 更新轨迹
        for (let j = bullet.trail.length - 1; j >= 0; j--) {
            bullet.trail[j].life -= deltaTime;
            if (bullet.trail[j].life <= 0) {
                bullet.trail.splice(j, 1);
            }
        }
        
        // 检查子弹是否击中怪物
        let hitMonster = false;
        for (let j = this.monsters.length - 1; j >= 0; j--) {
            const monster = this.monsters[j];
            
            // 检测子弹和怪物的碰撞
            if (this.isColliding(bullet, monster)) {
                const groundY = this.mapHeight - 50;
                const monsterY = groundY - monster.height;
                const monsterCenterX = monster.x + monster.width / 2;
                const monsterCenterY = monsterY + monster.height / 2;
                
                // 添加轨迹点到怪物中心
                bullet.trail.push({x: monsterCenterX, y: monsterCenterY, life: 200});
                
                // 将子弹位置调整到怪物中心
                bullet.x = monsterCenterX;
                bullet.y = monsterCenterY;
                
                // 创建爆炸效果
                this.createExplosion(monsterCenterX, monsterCenterY);
                
                // 造成伤害
                const damage = bullet.damage;
                monster.hp -= damage;
                
                this.addCombatText(monsterCenterX, monsterY - 10, `-${this.formatNumber(damage)}`, '#ff4757');
                
                // 怪物死亡
                if (monster.hp <= 0) {
                    this.coins += monster.coinReward;
                    this.addCombatText(monsterCenterX, monsterY - 20, `+${this.formatNumber(monster.coinReward)} 金币`, '#ffd700');
                    
                    // 有概率获得红宝石
                    if (Math.random() < 0.1) { // 10%概率
                        const rubyReward = 1 + Math.floor(Math.random() * 3); // 1-3个红宝石
                        this.rubies += rubyReward;
                        this.addCombatText(monsterCenterX, monsterY - 35, `+${rubyReward} 红宝石`, '#ff4757');
                    }
                    
                    // 移除怪物
                    this.monsters.splice(j, 1);
                }
                
                // 移除子弹
                this.bullets.splice(i, 1);
                hitMonster = true;
                break;
            }
        }
        
        // 如果没有击中怪物，检查是否超出屏幕
        if (!hitMonster && (bullet.life <= 0 || 
            bullet.x < -50 || bullet.x > this.mapWidth + 50 ||
            bullet.y < -50 || bullet.y > this.mapHeight + 50)) {
            this.bullets.splice(i, 1);
        }
    }
}
```

**功能**: 更新所有子弹状态

**更新内容**:
- 子弹移动
- 轨迹管理
- 碰撞检测
- 伤害计算
- 奖励发放

### 5. 子弹渲染 (drawBullets)

```javascript
drawBullets() {
    for (let bullet of this.bullets) {
        // 绘制子弹轨迹
        if (bullet.trail.length > 1) {
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            
            // 绘制轨迹到子弹当前位置
            for (let i = 0; i < bullet.trail.length; i++) {
                const point = bullet.trail[i];
                
                if (i === 0) {
                    this.ctx.moveTo(point.x, point.y);
                } else {
                    this.ctx.lineTo(point.x, point.y);
                }
            }
            
            // 确保轨迹连接到子弹当前位置
            this.ctx.lineTo(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
            
            this.ctx.stroke();
        }
        
        // 绘制子弹本体
        this.ctx.fillStyle = '#ffff00';
        this.ctx.beginPath();
        this.ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/2, 0, Math.PI * 2);
        this.ctx.fill();
        
        // 子弹发光效果
        this.ctx.shadowColor = '#ffff00';
        this.ctx.shadowBlur = 10;
        this.ctx.fillStyle = '#ffffff';
        this.ctx.beginPath();
        this.ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/4, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
    }
}
```

**功能**: 渲染所有子弹

**渲染内容**:
- 子弹轨迹
- 子弹本体
- 发光效果

## 爆炸系统

### 1. 爆炸数据结构

```javascript
const explosion = {
    x: x,                    // X坐标
    y: y,                    // Y坐标
    radius: 0,               // 当前半径
    maxRadius: 30,           // 最大半径
    life: 300,               // 存活时间 (300ms)
    particles: []            // 爆炸粒子
};
```

### 2. 创建爆炸效果 (createExplosion)

```javascript
createExplosion(x, y) {
    const explosion = {
        x: x,
        y: y,
        radius: 0,
        maxRadius: 30,
        life: 300, // 爆炸持续时间
        particles: []
    };
    
    // 创建爆炸粒子
    for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 / 8) * i;
        explosion.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * 100,
            vy: Math.sin(angle) * 100,
            life: 200,
            maxLife: 200
        });
    }
    
    this.explosions.push(explosion);
}
```

**功能**: 创建爆炸效果

**爆炸特性**:
- 圆形爆炸
- 8个粒子
- 300ms持续时间

### 3. 爆炸更新 (updateExplosions)

```javascript
updateExplosions(deltaTime) {
    for (let i = this.explosions.length - 1; i >= 0; i--) {
        const explosion = this.explosions[i];
        
        // 更新爆炸半径
        explosion.radius = (1 - explosion.life / 300) * explosion.maxRadius;
        
        // 更新粒子
        for (let j = explosion.particles.length - 1; j >= 0; j--) {
            const particle = explosion.particles[j];
            particle.x += particle.vx * (deltaTime / 1000);
            particle.y += particle.vy * (deltaTime / 1000);
            particle.life -= deltaTime;
            
            if (particle.life <= 0) {
                explosion.particles.splice(j, 1);
            }
        }
        
        // 减少爆炸生命
        explosion.life -= deltaTime;
        
        // 移除过期的爆炸
        if (explosion.life <= 0) {
            this.explosions.splice(i, 1);
        }
    }
}
```

**功能**: 更新所有爆炸效果

### 4. 爆炸渲染 (drawExplosions)

```javascript
drawExplosions() {
    for (let explosion of this.explosions) {
        const alpha = explosion.life / 300;
        
        // 绘制爆炸圆圈
        this.ctx.strokeStyle = `rgba(255, 100, 0, ${alpha})`;
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // 绘制内圈
        this.ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.8})`;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(explosion.x, explosion.y, explosion.radius * 0.6, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // 绘制粒子
        for (let particle of explosion.particles) {
            const particleAlpha = particle.life / particle.maxLife;
            this.ctx.fillStyle = `rgba(255, 150, 0, ${particleAlpha})`;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
}
```

**功能**: 渲染所有爆炸效果

## 碰撞检测系统

### 1. 碰撞检测算法 (isColliding)

```javascript
isColliding(rect1, rect2) {
    // 如果是怪物，使用调整后的Y位置
    let rect2Y = rect2.y;
    if (rect2.hasOwnProperty('width') && rect2.hasOwnProperty('height') && rect2.hasOwnProperty('hp')) {
        // 这是怪物，使用调整后的Y位置
        const groundY = this.mapHeight - 50;
        rect2Y = groundY - rect2.height;
    }
    
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2Y + rect2.height &&
           rect1.y + rect1.height > rect2Y;
}
```

**功能**: 检测两个矩形是否碰撞

**算法**: AABB (Axis-Aligned Bounding Box) 碰撞检测

### 2. 距离计算 (getDistance)

```javascript
getDistance(obj1, obj2) {
    const dx = (obj1.x + obj1.width/2) - (obj2.x + obj2.width/2);
    const dy = (obj1.y + obj1.height/2) - (obj2.y + obj2.height/2);
    return Math.sqrt(dx * dx + dy * dy);
}
```

**功能**: 计算两个对象之间的距离

### 3. 近战战斗检测 (checkCombat)

```javascript
checkCombat() {
    for (let i = this.monsters.length - 1; i >= 0; i--) {
        const monster = this.monsters[i];
        
        // 检测玩家和怪物的碰撞
        if (this.isColliding(this.player, monster)) {
            this.combat(monster, i);
        }
    }
}
```

**功能**: 检测近战战斗

## 战斗文字系统

### 1. 战斗文字数据结构

```javascript
const combatText = {
    x: x,                    // X坐标
    y: y,                    // Y坐标
    text: text,              // 文字内容
    color: color,            // 文字颜色
    life: 2000,              // 存活时间 (2秒)
    opacity: 1               // 透明度
};
```

### 2. 添加战斗文字 (addCombatText)

```javascript
addCombatText(x, y, text, color) {
    this.combatTexts.push({
        x: x,
        y: y,
        text: text,
        color: color,
        life: 2000, // 2秒显示时间
        opacity: 1
    });
}
```

**功能**: 添加战斗文字

### 3. 战斗文字更新 (updateCombatTexts)

```javascript
updateCombatTexts(deltaTime) {
    for (let i = this.combatTexts.length - 1; i >= 0; i--) {
        const text = this.combatTexts[i];
        text.life -= deltaTime;
        text.y -= 30 * (deltaTime / 1000); // 向上飘动
        text.opacity = text.life / 2000;
        
        if (text.life <= 0) {
            this.combatTexts.splice(i, 1);
        }
    }
}
```

**功能**: 更新所有战斗文字

**更新内容**:
- 生命值递减
- 向上飘动
- 透明度变化

### 4. 战斗文字渲染 (drawCombatTexts)

```javascript
drawCombatTexts() {
    this.ctx.font = '14px Arial';
    this.ctx.textAlign = 'center';
    
    this.combatTexts.forEach(text => {
        this.ctx.globalAlpha = text.opacity;
        this.ctx.fillStyle = text.color;
        this.ctx.fillText(text.text, text.x, text.y);
    });
    
    this.ctx.globalAlpha = 1;
    this.ctx.textAlign = 'left';
}
```

**功能**: 渲染所有战斗文字

## 近战战斗系统

### 1. 近战战斗 (combat)

```javascript
combat(monster, monsterIndex) {
    // 玩家攻击怪物
    const playerDamage = Math.max(1, this.player.attack - Math.floor(monster.attack / 3));
    monster.hp -= playerDamage;
    
    const groundY = this.mapHeight - 50;
    const monsterY = groundY - monster.height;
    this.addCombatText(monster.x + monster.width/2, monsterY - 10, `-${this.formatNumber(playerDamage)}`, '#ff4757');
    
    // 怪物死亡
    if (monster.hp <= 0) {
        this.coins += monster.coinReward;
        this.addCombatText(monster.x + monster.width/2, monsterY - 20, `+${this.formatNumber(monster.coinReward)} 金币`, '#ffd700');
        
        // 有概率获得红宝石
        if (Math.random() < 0.1) { // 10%概率
            const rubyReward = 1 + Math.floor(Math.random() * 3); // 1-3个红宝石
            this.rubies += rubyReward;
            this.addCombatText(monster.x + monster.width/2, monsterY - 35, `+${rubyReward} 红宝石`, '#ff4757');
        }
        
        // 移除怪物
        this.monsters.splice(monsterIndex, 1);
    } else {
        // 怪物反击 - 直接造成伤害，不使用防御力
        const monsterDamage = monster.attack;
        this.player.hp -= monsterDamage;
        
        const groundY = this.mapHeight - 50;
        const playerY = groundY - this.player.height;
        this.addCombatText(this.player.x + this.player.width/2, playerY - 10, `-${this.formatNumber(monsterDamage)}`, '#ff6b6b');
        
        // 玩家死亡检查
        if (this.player.hp <= 0) {
            this.player.hp = this.player.maxHp;
            this.addCombatText(this.player.x + this.player.width/2, playerY - 30, '复活!', '#2ed573');
        }
    }
}
```

**功能**: 处理近战战斗

**战斗逻辑**:
- 玩家攻击怪物
- 怪物反击玩家
- 死亡处理
- 奖励发放

## 性能优化

### 1. 对象池管理
```javascript
// 子弹对象池
class BulletPool {
    constructor() {
        this.pool = [];
        this.active = [];
    }
    
    get() {
        if (this.pool.length > 0) {
            return this.pool.pop();
        }
        return this.create();
    }
    
    release(bullet) {
        this.pool.push(bullet);
        const index = this.active.indexOf(bullet);
        if (index > -1) {
            this.active.splice(index, 1);
        }
    }
    
    create() {
        return {
            x: 0, y: 0, width: 6, height: 6,
            speed: 300, dirX: 1, dirY: 0,
            damage: 0, life: 2000, trail: []
        };
    }
}
```

### 2. 空间分割优化
```javascript
// 空间分割碰撞检测
class SpatialGrid {
    constructor(cellSize) {
        this.cellSize = cellSize;
        this.grid = new Map();
    }
    
    getCellKey(x, y) {
        return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`;
    }
    
    addObject(obj) {
        const key = this.getCellKey(obj.x, obj.y);
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(obj);
    }
    
    getNearbyObjects(x, y) {
        const key = this.getCellKey(x, y);
        return this.grid.get(key) || [];
    }
}
```

### 3. 批量处理
```javascript
// 批量更新怪物
updateMonstersBatch(deltaTime) {
    const batchSize = 10;
    const startIndex = this.lastProcessedIndex || 0;
    const endIndex = Math.min(startIndex + batchSize, this.monsters.length);
    
    for (let i = startIndex; i < endIndex; i++) {
        this.updateMonster(this.monsters[i], deltaTime);
    }
    
    this.lastProcessedIndex = endIndex >= this.monsters.length ? 0 : endIndex;
}
```

## 扩展性设计

### 1. 新怪物类型
```javascript
// 怪物类型枚举
const MonsterType = {
    GOBLIN: 'goblin',
    ORC: 'orc',
    DRAGON: 'dragon'
};

// 怪物配置
const MONSTER_CONFIG = {
    [MonsterType.GOBLIN]: {
        hp: 30, attack: 8, speed: 30, color: '#ff6b6b'
    },
    [MonsterType.ORC]: {
        hp: 60, attack: 15, speed: 20, color: '#4ecdc4'
    },
    [MonsterType.DRAGON]: {
        hp: 200, attack: 50, speed: 10, color: '#dda0dd'
    }
};
```

### 2. 新子弹类型
```javascript
// 子弹类型枚举
const BulletType = {
    NORMAL: 'normal',
    EXPLOSIVE: 'explosive',
    PIERCING: 'piercing'
};

// 子弹配置
const BULLET_CONFIG = {
    [BulletType.NORMAL]: {
        speed: 300, damage: 1, life: 2000
    },
    [BulletType.EXPLOSIVE]: {
        speed: 250, damage: 2, life: 1500, explosionRadius: 50
    },
    [BulletType.PIERCING]: {
        speed: 400, damage: 1, life: 3000, pierceCount: 3
    }
};
```

### 3. 新战斗效果
```javascript
// 战斗效果系统
class CombatEffect {
    constructor(type, duration, data) {
        this.type = type;
        this.duration = duration;
        this.data = data;
        this.timer = 0;
    }
    
    update(deltaTime) {
        this.timer += deltaTime;
        return this.timer >= this.duration;
    }
    
    apply(target) {
        switch (this.type) {
            case 'poison':
                target.hp -= this.data.damage;
                break;
            case 'slow':
                target.speed *= this.data.factor;
                break;
            case 'stun':
                target.stunned = true;
                break;
        }
    }
}
```

## 最佳实践

### 1. 性能优化
- 使用对象池减少垃圾回收
- 实现空间分割优化碰撞检测
- 批量处理相似操作

### 2. 代码组织
- 将相关功能组织在一起
- 使用清晰的命名约定
- 添加适当的注释

### 3. 错误处理
- 检查边界条件
- 处理异常情况
- 提供友好的错误信息

### 4. 可维护性
- 保持代码简洁
- 使用配置而非硬编码
- 实现模块化设计
