# 游戏核心系统

## 概述

游戏核心系统是整个 Pet Plan 游戏的基础框架，负责协调各个子系统，管理游戏循环，处理渲染和更新逻辑。

## 核心组件

### 1. Game 类

**位置**: `js/game.js` (第3-1826行)

**主要职责**:
- 游戏初始化和配置
- 游戏循环管理
- 子系统协调
- 事件处理
- 渲染管理

#### 构造函数
```javascript
constructor() {
    // 画布初始化
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    
    // 数字格式化系统
    this.numberSuffixes = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
    
    // 游戏状态
    this.isRunning = true;
    this.lastTime = 0;
    
    // 初始化各个子系统
    this.init();
}
```

#### 核心方法

##### 游戏循环 (gameLoop)
```javascript
gameLoop(currentTime = 0) {
    if (!this.isRunning) {
        requestAnimationFrame((time) => this.gameLoop(time));
        return;
    }
    
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    this.update(deltaTime);
    this.render();
    
    requestAnimationFrame((time) => this.gameLoop(time));
}
```

**功能**: 游戏主循环，使用 `requestAnimationFrame` 确保流畅的60FPS渲染

**参数**:
- `currentTime`: 当前时间戳

**流程**:
1. 检查游戏是否运行
2. 计算时间差 (deltaTime)
3. 更新游戏逻辑
4. 渲染游戏画面
5. 请求下一帧

##### 更新逻辑 (update)
```javascript
update(deltaTime) {
    // 更新玩家移动
    this.updatePlayer(deltaTime);
    
    // 更新怪物生成
    this.updateMonsterSpawn(deltaTime);
    
    // 更新怪物
    this.updateMonsters(deltaTime);
    
    // 更新子弹
    this.updateBullets(deltaTime);
    
    // 更新爆炸效果
    this.updateExplosions(deltaTime);
    
    // 更新自动攻击
    this.updateAutoAttack(deltaTime);
    
    // 检测近战战斗
    this.checkCombat();
    
    // 更新战斗文字
    this.updateCombatTexts(deltaTime);
    
    // 更新UI
    this.updateUI();
}
```

**功能**: 每帧更新所有游戏系统

**参数**:
- `deltaTime`: 距离上一帧的时间差（毫秒）

##### 渲染逻辑 (render)
```javascript
render() {
    // 清空画布
    this.ctx.fillStyle = '#87ceeb';
    this.ctx.fillRect(0, 0, this.mapWidth, this.mapHeight);
    
    // 绘制地面
    this.ctx.fillStyle = '#90ee90';
    this.ctx.fillRect(0, this.mapHeight - 50, this.mapWidth, 50);
    
    // 绘制各种游戏元素
    this.drawGrassTexture();
    this.drawClouds();
    this.drawPlayer();
    this.drawBullets();
    this.drawExplosions();
    this.drawMonsters();
    this.drawCombatTexts();
    this.drawGameInfo();
}
```

**功能**: 渲染游戏画面

**渲染顺序**:
1. 背景 (天空)
2. 地面
3. 地面纹理
4. 云朵
5. 玩家
6. 子弹
7. 爆炸效果
8. 怪物
9. 战斗文字
10. UI信息

## 数字格式化系统

### formatNumber 方法
```javascript
formatNumber(num) {
    if (num < 1000) {
        return Math.floor(num).toString();
    }
    
    let value = num;
    let suffix = '';
    
    // 计算需要多少个1000的倍数
    let power = 0;
    while (value >= 1000) {
        value /= 1000;
        power++;
    }
    
    // 生成后缀
    if (power <= 26) {
        // 单字母系统 (A-Z)
        suffix = this.numberSuffixes[power];
    } else {
        // 双字母系统 (AA, AB, AC, ..., AZ, BA, BB, ...)
        const firstLetterIndex = Math.floor((power - 27) / 26) + 1;
        const secondLetterIndex = (power - 27) % 26 + 1;
        
        suffix = this.numberSuffixes[firstLetterIndex] + this.numberSuffixes[secondLetterIndex];
    }
    
    // 保留适当的小数位数
    if (value >= 100) {
        return Math.floor(value) + suffix;
    } else if (value >= 10) {
        return value.toFixed(1) + suffix;
    } else {
        return value.toFixed(2) + suffix;
    }
}
```

**功能**: 将大数字转换为易读格式

**示例**:
- 1000 → "1A"
- 1000000 → "1B"
- 1000000000 → "1C"
- 1000000000000 → "1AA"

## 事件系统

### 事件绑定 (bindEvents)
```javascript
bindEvents() {
    // 升级按钮事件
    this.bindUpgradeButton('upgradeAttack', 'attack', 5);
    this.bindUpgradeButton('upgradeHp', 'hp', 20);
    // ... 其他升级按钮
    
    // 长按升级菜单
    this.bindLongPressUpgradeMenu();
    
    // 状态图标事件
    this.bindStatusIconEvents();
    
    // 导航栏事件
    this.bindNavigationEvents();
    
    // 触摸反馈
    this.addTouchFeedback();
}
```

**功能**: 绑定所有用户交互事件

### 升级按钮绑定
```javascript
bindUpgradeButton(buttonId, attribute, increase) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    let longPressTimer = null;
    let isLongPressing = false;
    let repeatTimer = null;
    
    // 开始长按
    const startLongPress = () => {
        this.upgradeAttribute(attribute, increase);
        
        longPressTimer = setTimeout(() => {
            isLongPressing = true;
            repeatTimer = setInterval(() => {
                this.upgradeAttribute(attribute, increase);
            }, 150);
        }, 500);
    };
    
    // 停止长按
    const stopLongPress = () => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        if (repeatTimer) {
            clearInterval(repeatTimer);
            repeatTimer = null;
        }
        isLongPressing = false;
    };
    
    // 绑定鼠标和触摸事件
    button.addEventListener('mousedown', startLongPress);
    button.addEventListener('mouseup', stopLongPress);
    button.addEventListener('mouseleave', stopLongPress);
    button.addEventListener('touchstart', startLongPress);
    button.addEventListener('touchend', stopLongPress);
    button.addEventListener('touchcancel', stopLongPress);
}
```

**功能**: 为升级按钮添加长按和重复升级功能

**特性**:
- 支持鼠标和触摸操作
- 长按500ms后开始重复升级
- 每150ms执行一次升级
- 防止重复点击

## 工具提示系统

### showStatusTooltip 方法
```javascript
showStatusTooltip(element, message) {
    const tooltip = document.createElement('div');
    tooltip.className = 'status-tooltip';
    tooltip.textContent = message;
    tooltip.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        z-index: 1000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    
    document.body.appendChild(tooltip);
    
    // 定位工具提示
    const rect = element.getBoundingClientRect();
    tooltip.style.left = rect.left + rect.width / 2 - tooltip.offsetWidth / 2 + 'px';
    tooltip.style.top = rect.top - tooltip.offsetHeight - 8 + 'px';
    
    // 显示动画
    setTimeout(() => {
        tooltip.style.opacity = '1';
    }, 10);
    
    // 3秒后移除
    setTimeout(() => {
        tooltip.style.opacity = '0';
        setTimeout(() => {
            if (tooltip.parentNode) {
                tooltip.parentNode.removeChild(tooltip);
            }
        }, 300);
    }, 3000);
}
```

**功能**: 显示状态图标的工具提示

**特性**:
- 自动定位
- 淡入淡出动画
- 3秒自动消失
- 响应式设计

## 性能优化

### 1. 渲染优化
- 使用 `requestAnimationFrame` 确保流畅渲染
- 只重绘变化的区域
- 对象池管理子弹和爆炸效果

### 2. 内存管理
- 及时清理过期的游戏对象
- 复用 DOM 元素
- 避免内存泄漏

### 3. 计算优化
- 缓存计算结果
- 使用高效的碰撞检测算法
- 批量处理相似操作

## 错误处理

### 初始化错误处理
```javascript
constructor() {
    this.canvas = document.getElementById('gameCanvas');
    if (!this.canvas) {
        console.error('无法找到游戏画布元素');
        return;
    }
    
    this.ctx = this.canvas.getContext('2d');
    if (!this.ctx) {
        console.error('无法获取画布上下文');
        return;
    }
    
    // ... 其他初始化代码
}
```

### 图片加载错误处理
```javascript
this.playerImage.onload = () => {
    this.playerImageLoaded = true;
    console.log('角色图片加载成功');
};

this.playerImage.onerror = () => {
    console.error('角色图片加载失败:', this.playerImage.src);
    this.playerImageLoaded = false;
};
```

## 扩展性设计

### 1. 模块化支持
游戏核心系统设计为可扩展的架构，支持添加新的子系统：

```javascript
// 添加新系统
this.newSystem = new NewSystem();
this.systems.push(this.newSystem);

// 在更新循环中调用
update(deltaTime) {
    // ... 现有更新逻辑
    this.newSystem.update(deltaTime);
}

// 在渲染循环中调用
render() {
    // ... 现有渲染逻辑
    this.newSystem.render(this.ctx);
}
```

### 2. 配置化设计
游戏参数通过配置对象管理：

```javascript
const GAME_CONFIG = {
    canvas: {
        width: 400,
        height: 435
    },
    player: {
        initialX: 35,
        initialY: 0,
        width: 51,
        height: 51
    },
    combat: {
        monsterSpawnInterval: 2000,
        attackInterval: 800
    }
};
```

### 3. 事件系统扩展
支持自定义事件：

```javascript
// 触发自定义事件
this.emit('custom:event', { data: 'value' });

// 监听自定义事件
this.on('custom:event', (data) => {
    console.log('收到自定义事件:', data);
});
```

## 调试和监控

### 1. 性能监控
```javascript
// 监控帧率
let frameCount = 0;
let lastFpsTime = 0;

function updateFPS(currentTime) {
    frameCount++;
    if (currentTime - lastFpsTime >= 1000) {
        console.log('FPS:', frameCount);
        frameCount = 0;
        lastFpsTime = currentTime;
    }
}
```

### 2. 内存监控
```javascript
// 监控内存使用
function checkMemory() {
    if (performance.memory) {
        console.log('内存使用:', {
            used: performance.memory.usedJSHeapSize,
            total: performance.memory.totalJSHeapSize,
            limit: performance.memory.jsHeapSizeLimit
        });
    }
}
```

### 3. 调试模式
```javascript
// 调试模式开关
const DEBUG_MODE = true;

if (DEBUG_MODE) {
    // 显示调试信息
    this.drawDebugInfo();
    
    // 记录性能数据
    this.recordPerformance();
}
```

## 最佳实践

### 1. 代码组织
- 将相关功能组织在一起
- 使用清晰的命名约定
- 添加适当的注释

### 2. 错误处理
- 始终检查关键操作的结果
- 提供有意义的错误信息
- 实现优雅的降级处理

### 3. 性能考虑
- 避免在游戏循环中进行重计算
- 使用对象池减少垃圾回收
- 优化渲染性能

### 4. 可维护性
- 保持代码简洁
- 使用配置而非硬编码
- 实现模块化设计
