# 数据流设计

## 数据流架构概览

Pet Plan 采用单向数据流架构，确保数据的一致性和可预测性。数据流向遵循以下原则：

```
用户操作 → 事件触发 → 状态更新 → UI 重渲染 → 用户反馈
```

## 核心数据模型

### 1. 游戏状态 (Game State)
```javascript
const gameState = {
    // 游戏运行状态
    isRunning: true,
    lastTime: 0,
    
    // 画布信息
    canvas: {
        width: 400,
        height: 435
    },
    
    // 地图信息
    map: {
        width: 400,
        height: 435
    }
};
```

### 2. 玩家数据 (Player Data)
```javascript
const playerData = {
    // 位置信息
    position: {
        x: 35,
        y: 0,
        width: 51,
        height: 51
    },
    
    // 移动属性
    movement: {
        speed: 50,
        direction: 1,
        animationFrame: 0
    },
    
    // 战斗属性
    combat: {
        level: 1,
        hp: 100,
        maxHp: 100,
        attack: 20,
        hpRegen: 1,
        critDamage: 150,
        attackSpeed: 1.0,
        crit: 5,
        multiShot: 1,
        tripleShot: 0
    },
    
    // 升级成本
    upgradeCosts: {
        attack: 10,
        hp: 15,
        hpRegen: 20,
        critDamage: 25,
        attackSpeed: 30,
        crit: 35,
        multiShot: 40,
        tripleShot: 50
    }
};
```

### 3. 资源数据 (Resource Data)
```javascript
const resourceData = {
    // 货币
    currency: {
        coins: 1000,
        rubies: 50
    },
    
    // 数字格式化配置
    numberFormat: {
        suffixes: ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
    }
};
```

### 4. 战斗数据 (Combat Data)
```javascript
const combatData = {
    // 怪物列表
    monsters: [],
    
    // 子弹列表
    bullets: [],
    
    // 爆炸效果
    explosions: [],
    
    // 战斗文字
    combatTexts: [],
    
    // 生成配置
    spawn: {
        timer: 0,
        interval: 2000
    },
    
    // 攻击配置
    attack: {
        timer: 0,
        interval: 800,
        range: 500
    }
};
```

## 数据流实现

### 1. 状态管理器 (State Manager)
```javascript
class StateManager {
    constructor() {
        this.state = {
            game: gameState,
            player: playerData,
            resources: resourceData,
            combat: combatData
        };
        
        this.listeners = new Map();
    }
    
    // 获取状态
    getState(path) {
        return this.getNestedValue(this.state, path);
    }
    
    // 设置状态
    setState(path, value) {
        this.setNestedValue(this.state, path, value);
        this.notifyListeners(path, value);
    }
    
    // 订阅状态变化
    subscribe(path, callback) {
        if (!this.listeners.has(path)) {
            this.listeners.set(path, []);
        }
        this.listeners.get(path).push(callback);
    }
    
    // 取消订阅
    unsubscribe(path, callback) {
        const callbacks = this.listeners.get(path);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    
    // 通知监听器
    notifyListeners(path, value) {
        const callbacks = this.listeners.get(path);
        if (callbacks) {
            callbacks.forEach(callback => callback(value));
        }
    }
    
    // 获取嵌套值
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    }
    
    // 设置嵌套值
    setNestedValue(obj, path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((current, key) => {
            if (!current[key]) current[key] = {};
            return current[key];
        }, obj);
        target[lastKey] = value;
    }
}
```

### 2. 数据流示例

#### 升级系统数据流
```javascript
// 1. 用户点击升级按钮
document.getElementById('upgradeAttack').addEventListener('click', () => {
    // 2. 触发升级事件
    eventSystem.emit('upgrade:request', {
        attribute: 'attack',
        amount: 5
    });
});

// 3. 升级系统处理事件
eventSystem.on('upgrade:request', (data) => {
    const { attribute, amount } = data;
    
    // 4. 检查资源是否足够
    const cost = stateManager.getState(`player.upgradeCosts.${attribute}`);
    const coins = stateManager.getState('resources.currency.coins');
    
    if (coins >= cost) {
        // 5. 更新玩家属性
        const currentValue = stateManager.getState(`player.combat.${attribute}`);
        stateManager.setState(`player.combat.${attribute}`, currentValue + amount);
        
        // 6. 扣除资源
        stateManager.setState('resources.currency.coins', coins - cost);
        
        // 7. 更新升级成本
        const newCost = Math.floor(cost * 1.5);
        stateManager.setState(`player.upgradeCosts.${attribute}`, newCost);
        
        // 8. 触发UI更新事件
        eventSystem.emit('ui:update', {
            type: 'upgrade',
            attribute: attribute
        });
    }
});

// 9. UI系统响应更新
eventSystem.on('ui:update', (data) => {
    if (data.type === 'upgrade') {
        updateUpgradeButtons();
        updateUpgradeItems();
        updateTotalPower();
    }
});
```

#### 战斗系统数据流
```javascript
// 1. 游戏循环更新
function gameLoop(currentTime) {
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // 2. 更新战斗系统
    updateCombat(deltaTime);
    
    // 3. 检查碰撞
    checkCollisions();
    
    // 4. 更新UI
    updateUI();
    
    // 5. 渲染
    render();
    
    requestAnimationFrame(gameLoop);
}

// 3. 碰撞检测
function checkCollisions() {
    const bullets = stateManager.getState('combat.bullets');
    const monsters = stateManager.getState('combat.monsters');
    
    bullets.forEach((bullet, bulletIndex) => {
        monsters.forEach((monster, monsterIndex) => {
            if (isColliding(bullet, monster)) {
                // 4. 计算伤害
                const damage = stateManager.getState('player.combat.attack');
                
                // 5. 更新怪物血量
                const newHp = monster.hp - damage;
                stateManager.setState(`combat.monsters.${monsterIndex}.hp`, newHp);
                
                // 6. 怪物死亡处理
                if (newHp <= 0) {
                    const coinReward = monster.coinReward;
                    const currentCoins = stateManager.getState('resources.currency.coins');
                    stateManager.setState('resources.currency.coins', currentCoins + coinReward);
                    
                    // 移除怪物
                    const updatedMonsters = monsters.filter((_, index) => index !== monsterIndex);
                    stateManager.setState('combat.monsters', updatedMonsters);
                }
                
                // 7. 移除子弹
                const updatedBullets = bullets.filter((_, index) => index !== bulletIndex);
                stateManager.setState('combat.bullets', updatedBullets);
            }
        });
    });
}
```

## 数据持久化

### 1. 本地存储 (LocalStorage)
```javascript
class DataPersistence {
    constructor(stateManager) {
        this.stateManager = stateManager;
        this.storageKey = 'pet-plan-save';
    }
    
    // 保存游戏数据
    saveGame() {
        const gameData = {
            player: this.stateManager.getState('player'),
            resources: this.stateManager.getState('resources'),
            timestamp: Date.now()
        };
        
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(gameData));
            console.log('游戏数据已保存');
        } catch (error) {
            console.error('保存游戏数据失败:', error);
        }
    }
    
    // 加载游戏数据
    loadGame() {
        try {
            const savedData = localStorage.getItem(this.storageKey);
            if (savedData) {
                const gameData = JSON.parse(savedData);
                
                // 恢复玩家数据
                Object.keys(gameData.player).forEach(key => {
                    this.stateManager.setState(`player.${key}`, gameData.player[key]);
                });
                
                // 恢复资源数据
                Object.keys(gameData.resources).forEach(key => {
                    this.stateManager.setState(`resources.${key}`, gameData.resources[key]);
                });
                
                console.log('游戏数据已加载');
                return true;
            }
        } catch (error) {
            console.error('加载游戏数据失败:', error);
        }
        return false;
    }
    
    // 清除保存数据
    clearSave() {
        localStorage.removeItem(this.storageKey);
        console.log('保存数据已清除');
    }
    
    // 自动保存
    enableAutoSave(interval = 30000) { // 30秒自动保存
        setInterval(() => {
            this.saveGame();
        }, interval);
    }
}
```

### 2. 数据验证
```javascript
class DataValidator {
    // 验证玩家数据
    validatePlayerData(data) {
        const schema = {
            combat: {
                level: { type: 'number', min: 1, max: 9999 },
                hp: { type: 'number', min: 1 },
                maxHp: { type: 'number', min: 1 },
                attack: { type: 'number', min: 1 },
                hpRegen: { type: 'number', min: 0 },
                critDamage: { type: 'number', min: 100 },
                attackSpeed: { type: 'number', min: 0.1, max: 10 },
                crit: { type: 'number', min: 0, max: 100 },
                multiShot: { type: 'number', min: 1, max: 100 },
                tripleShot: { type: 'number', min: 0, max: 100 }
            }
        };
        
        return this.validateObject(data, schema);
    }
    
    // 验证资源数据
    validateResourceData(data) {
        const schema = {
            currency: {
                coins: { type: 'number', min: 0 },
                rubies: { type: 'number', min: 0 }
            }
        };
        
        return this.validateObject(data, schema);
    }
    
    // 通用验证方法
    validateObject(obj, schema) {
        for (const [key, rules] of Object.entries(schema)) {
            if (!(key in obj)) {
                return { valid: false, error: `Missing field: ${key}` };
            }
            
            const value = obj[key];
            
            if (rules.type && typeof value !== rules.type) {
                return { valid: false, error: `Invalid type for ${key}: expected ${rules.type}` };
            }
            
            if (rules.min !== undefined && value < rules.min) {
                return { valid: false, error: `Value too small for ${key}: ${value} < ${rules.min}` };
            }
            
            if (rules.max !== undefined && value > rules.max) {
                return { valid: false, error: `Value too large for ${key}: ${value} > ${rules.max}` };
            }
        }
        
        return { valid: true };
    }
}
```

## 数据流优化

### 1. 批量更新
```javascript
class BatchUpdater {
    constructor(stateManager) {
        this.stateManager = stateManager;
        this.pendingUpdates = new Map();
        this.updateTimer = null;
    }
    
    // 批量设置状态
    batchSetState(path, value) {
        this.pendingUpdates.set(path, value);
        
        if (!this.updateTimer) {
            this.updateTimer = setTimeout(() => {
                this.flushUpdates();
            }, 0);
        }
    }
    
    // 执行批量更新
    flushUpdates() {
        for (const [path, value] of this.pendingUpdates) {
            this.stateManager.setState(path, value);
        }
        
        this.pendingUpdates.clear();
        this.updateTimer = null;
    }
}
```

### 2. 数据缓存
```javascript
class DataCache {
    constructor() {
        this.cache = new Map();
        this.maxSize = 100;
    }
    
    // 获取缓存数据
    get(key) {
        const item = this.cache.get(key);
        if (item) {
            item.lastAccessed = Date.now();
            return item.value;
        }
        return null;
    }
    
    // 设置缓存数据
    set(key, value, ttl = 60000) { // 默认1分钟过期
        if (this.cache.size >= this.maxSize) {
            this.evictOldest();
        }
        
        this.cache.set(key, {
            value: value,
            timestamp: Date.now(),
            lastAccessed: Date.now(),
            ttl: ttl
        });
    }
    
    // 清除过期缓存
    evictOldest() {
        let oldestKey = null;
        let oldestTime = Date.now();
        
        for (const [key, item] of this.cache) {
            if (item.lastAccessed < oldestTime) {
                oldestTime = item.lastAccessed;
                oldestKey = key;
            }
        }
        
        if (oldestKey) {
            this.cache.delete(oldestKey);
        }
    }
    
    // 清除过期数据
    cleanup() {
        const now = Date.now();
        for (const [key, item] of this.cache) {
            if (now - item.timestamp > item.ttl) {
                this.cache.delete(key);
            }
        }
    }
}
```

## 数据流监控

### 1. 性能监控
```javascript
class DataFlowMonitor {
    constructor() {
        this.metrics = {
            stateUpdates: 0,
            renderCalls: 0,
            averageUpdateTime: 0,
            peakMemoryUsage: 0
        };
    }
    
    // 记录状态更新
    recordStateUpdate(updateTime) {
        this.metrics.stateUpdates++;
        this.updateAverageTime(updateTime);
    }
    
    // 记录渲染调用
    recordRenderCall() {
        this.metrics.renderCalls++;
    }
    
    // 更新平均时间
    updateAverageTime(updateTime) {
        const total = this.metrics.averageUpdateTime * (this.metrics.stateUpdates - 1) + updateTime;
        this.metrics.averageUpdateTime = total / this.metrics.stateUpdates;
    }
    
    // 获取性能报告
    getPerformanceReport() {
        return {
            ...this.metrics,
            memoryUsage: this.getMemoryUsage(),
            timestamp: Date.now()
        };
    }
    
    // 获取内存使用情况
    getMemoryUsage() {
        if (performance.memory) {
            return {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            };
        }
        return null;
    }
}
```

## 数据流最佳实践

### 1. 状态不可变性
```javascript
// 错误做法：直接修改状态
state.player.hp = 100;

// 正确做法：创建新状态
stateManager.setState('player.hp', 100);
```

### 2. 单一数据源
```javascript
// 所有UI组件都从同一个状态管理器获取数据
const playerHp = stateManager.getState('player.combat.hp');
const playerMaxHp = stateManager.getState('player.combat.maxHp');
```

### 3. 数据标准化
```javascript
// 使用标准化的数据结构
const monsterData = {
    id: 'monster_001',
    type: 'goblin',
    position: { x: 100, y: 200 },
    stats: { hp: 50, attack: 10 },
    timestamp: Date.now()
};
```

### 4. 错误处理
```javascript
// 数据操作时添加错误处理
try {
    stateManager.setState('player.hp', newHp);
} catch (error) {
    console.error('更新玩家血量失败:', error);
    // 回滚到之前的状态或显示错误信息
}
```
